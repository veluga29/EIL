## Tips
- 주문 테이블은 orders로 주로 사용 (예약어 order by 때문에)
- 테이블 이름은 소문자 + `_` 스타일 사용
- 실무에서 `@ManyToMany`는 사용하지 말자
	- 중간 테이블에 컬럼을 추가할 수 없고 세밀한 쿼리가 어려움
	- `@ManyToOne`, `@OneToMany`로 풀어내서 사용
- 연관 관계에서 외래 키가 있는 곳을 연관 관계의 주인으로 정하기 (One-to-Many에서는 Many가 주인)
- Getter, Setter는 모두 제공하지 않고, 꼭 필요한 별도 메서드만 제공하는게 가장 이상적이지만 **실무는 다름**
	- Getter는 모두 열어놓으면 실무상 편리
	- 엔티티 변경은 Setter를 모두 열어두기 보다 **비즈니스 메서드를 별도 제공**해 변경 지점이 명확하도록 함
- 엔티티의 식별자는 `id`로 쓰더라도 PK 컬럼명은 `테이블명_id`로 사용하자
	- Foreign key와 이름을 맞출 수 있는 장점
	- DBA들도 선호
- `Cascade=ALL`
	- 엔티티를 persist하면 다른 연관관계 엔티티까지 **persist를 전파**
	- Delete할 때는 **모두 같이 지워짐**
- 값 타입(임베디드 타입)은 **변경 불가능**하게 설계
	- `@Setter`를 제거하고 **생성자에서 초기화 강제**
	- **기본 생성자를 `protected`로 두어 안전 향상**
		- JPA 스펙 상 엔티티 및 임베디드 타입은 기본 생성자를 `public` 혹은 `protected`로 두어야 함
		- JPA가 객체 생성시 리플랙션 같은 기술을 사용할 수 있도록 지원해야 하기 때문
- 엔티티 설계 시 주의점
	- 모든 연관관계는 **지연로딩**(**Lazy**)으로 설정
		- 즉시로딩(Eager)은 예측이 어렵고 N + 1 문제가 자주 발생
		- 연관 관계 엔티티 로딩 시 fetch join 혹은 엔티티 그래프 기능 사용
		- `@XToOne` 관계는 기본이 즉시로딩이므로 직접 지연로딩 설정을 해야 함
	- **컬렉션은 필드에서 초기화**
		- `null` 문제에서 안전
		- Hibernate은 엔티티 영속화 시 컬렉션을 감싸서 Hibernate이 제공하는 내장 컬렉션으로 변경 (PersistentBag) - 필드 초기화가 내부 매커니즘을 안전하게 지켜줌
	- 테이블, 컬럼명 생성 전략
		- 기본 전략
			- 하이버네이트 기존 구현
				- 엔티티의 필드명을 **그대로 테이블 컬럼명**으로 사용
				- `SpringPhysicalNamingStrategy`
			- 스프링 부트 신규 설정
				- Camel case -> **Snake case**
				- `.` -> `_`
		- 추가 전략
			- **명시적으로 컬럼, 테이블명을 적으면** 실제 테이블에 **물리명** 적용 (`physical-strategy`)
			- 적지 않은 경우 **논리명** 적용 (`implicit-strategy`)
