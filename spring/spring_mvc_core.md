## Web Server & Web Application Server
- Web Server (HTTP)
	- **정적 리소스 제공** + 기타 부가기능
	- 동적인 처리(애플리케이션 로직 등)가 필요하면 **WAS에 요청 위임**
	- 예시) NGINX, APACHE
- Web Application Server (HTTP)
	- **애플리케이션 로직 수행** (프로그램 코드 실행) + 웹 서버 기능 (정적 리소스 제공)
		- 동적 HTML, HTTP API(JSON), 서블릿, JSP, Spring MVC
	- API 서버만 제공할 경우 WAS만으로 서버 구축해도 괜찮음 (회사끼리 데이터 주고 받을 때)
	- 예시) Tomcat, Jetty, Undertow
- WAS는 애플리케이션 코드 실행에 더 **특화**되어 있다!
	- 웹서버와 WAS는 서로가 서로의 기능을 가지고 있긴 해서 경계가 모호
	- 서블릿 컨테이너 기능 제공하면 WAS라 보기도 함 (서블릿 사용안하는 프레임워크도 있지만...)
- 공존 이유
	- 효율적인 리소스 관리
		- WAS가 너무 많은 역할을 담당하여 **서버 과부하 우려**
		- **애플리케이션 로직은 값어치가 높으므로** 값이 낮은 정적 리소스 때문에 과부하되면 안됨
		- 역할 분리
			- 정적 리소스 사용이 많을 때는 Web Server 증설
			- 애플리케이션 리소스 사용이 많을 때는 WAS 증설
	- 지속적인 오류 화면 제공
		- WAS는 잘 죽는 반면, Web Server는 잘 안 죽음
		- WAS 및 DB 장애시 **Web Server가 오류화면 제공 가능**
## Servlet
- 메시지 수신, 파싱, 응답 메시지 생성 및 송신 등 **HTTP 스펙의편리한 사용**을 지원하는 자바 클래스
- 서블릿을 지원하는 WAS를 사용하면, **의미있는 비즈니스 로직에만 집중 가능**
- 사용 방법
	- 메인 함수가 실행되는 클래스에 `@ServletComponentScan` 추가
	- `HttpServlet`을 상속받고 `@WebServlet` 애노테이션에 `name`과 `urlPatterns`를 지정
	- `protected`의 `service` 코드를 오버라이딩해 비즈니스 로직 작성
	- `HttpServletRequest`와 `HttpServletResponse` 타입 파라미터로 요청 및 응답 정보 사용 가능
- 부가 기능
	- 임시 저장소 기능: HTTP 요청의 시작과 끝까지 유지, View에 데이터 전달하는 Model 역할도 수행
	- 세션 관리 기능: `request.getSession(create: true)`
- 흐름
	![](../images/servlet_flow.png)
	- HTTP 요청시 WAS가 `Request`, `Response` 객체를 생성해서 서블릿 객체 호출
	- 서비스 로직에서 `Request` 객체의 HTTP 요청 정보를 이용하고 `Response` 객체에 응답 정보 입력
	- WAS는 `Response` 객체에 담긴 내용으로 HTTP 응답 정보 생성
## Servlet Container(서블릿 컨테이너)
- **서블릿을 지원하는 WAS** (톰캣)
- 서블릿 객체의 **생명주기 관리** (생성, 초기화, 호출, 종료)
- 서블릿 객체를 **싱글톤**으로 관리
	- 최초 로딩 시점에 서블릿 객체를 미리 만들어두고 재활용
	- 공유 변수 사용에는 주의해야 함
- **동시 요청**을 위한 **멀티 쓰레드 처리** 지원
	- 덕분에 개발자가 멀티 쓰레드를 신경쓰지 않고 **마치 싱글 쓰레드 프로그래밍 하듯이** 편리하게 개발 (**WAS가 개발 생산성을 가장 높여주는 부분**)
	- 멀티 쓰레드 환경이므로 **싱글톤 객체(서블릿, 스프링 빈)는 주의해서 사용** (공유변수, 멤버변수 조심)
## 동시요청 (멀티 쓰레드)
- 쓰레드
	- 애플리케이션 코드를 하나하나 순차적으로 실행하는 것 (**한번에 하나의 코드 라인만 수행**)
	- 자바 메인 메서드를 처음 실행하면 main이라는 이름의 쓰레드가 실행
	- 동시 처리가 필요하면 쓰레드를 추가로 생성
	- **서블릿 객체는 쓰레드가 호출**
- **멀티 쓰레드는 동시요청 처리 가능** (단일 쓰레드로는 처리가 어려움)
	- 요청마다 쓰레드 생성
		- 장점
			- 동시 요청 처리 가능
			- 하나의 쓰레드가 지연 되어도, 나머지 쓰레드는 정상 동작
		- 단점
			- 쓰레드 생성 비용은 매우 비쌈 (요청마다 쓰레드 생성하면 응답 속도도 늦어짐)
			- 컨텍스트 스위칭 비용 발생 (하나의 CPU 코어에 2개 이상의 쓰레드를 돌리면 발생) 
			- 쓰레드 생성에 제한 없음 (요청이 너무 많으면, CPU와 메모리 임계점을 넘어 서버가 죽음)
	- **쓰레드 풀**
		- 설정한 최대치 만큼 **쓰레드를 미리 생성해 풀에 보관하고 관리** (톰캣 기본설정: 최대 200개)
		- 요청이 들어오면 쓰레드 풀에서 쓰레드를 할당하고 다 쓰면 반납 (**재사용**)
		- 풀에 남은 쓰레드가 부족하면 대기 중인 요청은 거절하거나 특정 숫자만큼만 대기하도록 설정 가능
		- 장점
			- 쓰레드를 미리 생성하므로, **쓰레드 생성 비용(CPU)이 절약**되고 **응답이 빠름**
			- **쓰레드 풀 최대치**가 있으므로 너무 많은 요청이 들어와도 **기존 요청은 안전하게 처리 가능**
		- WAS의 주요 튜닝 포인트는 **최대 쓰레드 수**(**max thread**)
			- 동시 요청이 많은 상황에서
				- 너무 낮게 설정 시: 서버 리소스는 여유롭지만, 금방 클라이언트 응답 지연이 발생
					- 100개 요청이 왔는데 최대 쓰레드가 10개면 동시에 10개 요청만 처리
					- 그런데 사실 CPU는 5% 밖에 사용안함
				- 너무 높게 설정 시: CPU, 메모리 임계점 초과로 서버 다운 발생
					- 10000개의 요청이 오면 10000개를 모두 받아들이다가 서버가 죽음
			- 장애 발생시
				- 클라우드면 일단 서버부터 늘리고 이후 튜닝
				- 클라우드가 아니면 바로 튜닝
			- **적정 쓰레드 풀 숫자는 성능 테스트를 통해 찾아야 함**
				- 애플리케이션 로직 복잡도, CPU & 메모리 & IO 리소스 상황에 따라 모두 다름
				- 최대한 실제 서비스와 유사하게 성능 테스트 시도
				- 아파치 ab, 제이미터, nGrinder
## 백엔드가 고려할 3가지 HTTP 통신
- **정적 리소스** 어떻게 제공할지
- **동적 HTML 페이지** 어떻게 제공할지 (**View Template**)
- **API** 어떻게 제공할지 (JSON)
## MVC 패턴
- 배경
	- 비즈니스 로직과 뷰는 **변경의 라이프 사이클이 다르므로, 분리하는 것이 좋은 설계**
	- 역할을 나누면 **유지보수성이 향상**되고 각각의 **기능을 특화**할 수 있음
- 컨트롤러 (Controller)
	- **HTTP 요청을 받아서 파라미터를 검증**하고 **비즈니스 로직 및 오케스트레이션 작업 실행**
	- 오케스트레이션: 데이터 접근 및 모델 담기 등의 작업
	- 지금은 더 고도화 되어서 다음 두 가지 패턴을 띔
		- 서비스 계층: 비즈니스 로직 + 오케스트레이션
		- 서비스 계층: 오케스트레이션 / 도메인 모델: 비즈니스 로직
- 모델 (Model)
	- **뷰에 출력할 데이터를 담아둠**
- 뷰 (View)
	- **화면을 렌더링**하는 일에 집중
	- HTML 생성에 더하여 XML, Excel, JSON 생성 등도 포괄
## SSR & CSR
- 서버 사이드 렌더링 (SSR)
	- HTML 최종 결과를 **서버에서 만들어서** 웹브라우저에 전달
	- JSP, Thymeleaf (백엔드 기술)
- 클라이언트 사이드 렌더링 (CSR)
	- HTML 최종 결과를 JS를 이용해 **웹 브라우저에서 동적으로 생성**해 적용
	- **필요한 부분만 부분부분 변경**
	- React, Vue.js (프론트엔드 기술)
- CSR + SSR 동시 지원하는 프론트 기술도 존재하므로 칼같이 나눌 필요 X (Next.js)
- SSR도 JS 이용해 화면 일부를 동적으로 변경 가능
## 자바 웹기술 역사
- Servlet(1997)
	- HTML 생성이 어려움 (동적 HTML을 생성할 수 있으나 자바코드로 일일히 HTML 만들어야 해서 불편)
- JSP(1999)
	- HTML 생성이 편리해 JSP로 모두 개발
	- 비즈니스 로직과 뷰 로직이 결합되어 **코드라인이 너무 많아지고 유지보수 저하**
- Servlet + JSP MVC 패턴
	- 모델, 뷰, 컨트롤러로 역할을 나눠 **비즈니스 로직과 화면 렌더링 부분을 나눔**
	- 한계점: **공통 기능 처리가 어려움**
		- `dispatcher.forward()` 같은 View로 이동하는 코드 중복
		- `/WEB-INF/views` 와 `.jsp` 같은 ViewPath 중복 (JSP 의존성도 증가)
		- `HttpServletResponse response`는 파라미터로 항상 존재하지만 사용 X
		- 공통 기능을 메서드로 뽑는 방안도 여전히 호출 중복이 존재하며 호출을 강제하지는 못함
		- **프론트 컨트롤러 패턴의 등장 배경**
- MVC 프레임워크 춘추 전국 시대 (2000년 초 ~ 2010년 초)
	- 반복되는 MVC 패턴을 자동화하기 위해 여러 프레임워크 등장
		- 스트럿츠, 웹워크, 스프링 MVC(과거 버전) 
		- 당시에는 스트럿츠 + 스프링 코어(MVC 제외한 service, DAO, repository) 형태를 주로 사용
	- FrontController 패턴 적용
		![](../images/front_controller_pattern.png)
		- **프론트 컨트롤러 서블릿 하나**로 클라이언트 요청을 받음 (나머지 컨트롤러는 서블릿 사용)
		- 프론트 컨트롤러가 **요청에 맞는 컨트롤러를 찾아 호출**
		- 공통 처리 담당
		- **스프링 MVC 핵심도 프론트 컨트롤러 패턴**
- **애노테이션 기반의 스프링 MVC**
	- MVC 프레임워크 혼돈 시대 정리
- **스프링 부트 (Spring Boot)**
	- 빌드 결과(Jar)에 **WAS 서버(Tomcat)를 포함**하여 **빌드 배포를 단순화**
		- 빌드된 Jar 파일을 아무 서버에 넣고 말아서 실행하면 됨
	- 과거에는 서버에 WAS(Tomcat)를 직접 설치하고 Jar 파일을 모아 War 파일을 만들어서 배포를 위한 특정 폴더에 집어 넣어 배포해야 했음
- 최신 기술 - 스프링 웹 기술의 분화
	- Web Servlet - Spring MVC
		- 서블릿 위에 Spring MVC를 올려서 동작
	- **Web Reactive - Spring WebFlux**
		- **비동기 Non-Blocking 처리**
		- **최소 쓰레드로 최대 성능** (**컨텍스트 스위칭 비용 효율화**)
			- CPU 코어가 4개 있으면 쓰레드 개수를 4 혹은 +1(5개) 정도로 맞춤
			- 고효율로 CPU 개수에 딱 맞췄기 때문에 쓰레드가 계속 돌아가고 컨텍스트 스위칭 비용이 거의 안듦
		- 함수형 스타일로 개발 - 동시처리 코드 효율화
			- WAS에서 상품 조회, 주문 서버 조회 등 여러 개의 서버에 여러 개 API를 동시에 찔러서 데이터를 가져와 조합해야 할 때 매우 효율적
			- Java 코드는 깔끔하지 않지만 함수형 스타일 코드는 매우 깔끔 (Netty)
		- 서블릿 사용 X
		- 단점
			- **기술적 난이도 매우 높음**
			- **RDB 지원 부족**
				- NoSQL(Redis, Elastic Search, DynamoDB, MongoDB)은 지원 잘 됨
			- 일반 MVC 쓰레드 모델도 충분히 빠름
				- 좋은 장비 띄워서 쓰레드 1000개 넣고 돌려도 잘 돌아감
			- 실무에서 아직 많이 사용 X
## 자바 뷰 템플릿 역사
- JSP
	- 느린 속도, 부족한 기능
- Freemarker, Velocity
	- 빠른 속도 (Thymeleaf 보다 빠름)
- **Thymeleaf** (권장)
	- 네추럴 템플릿
		- HTML 태그 속성을 이용하므로 HTML의 모양을 유지하면서 뷰 템플릿 적용 가능
	- 스프링 MVC와 강한 기능 통합
## 스프링 MVC
![](../images/spring_mvc_core_architecture.jpeg)
- 구조
	- **DispatcherServlet**
		- **프론트 컨트롤러** (스프링 MVC의 핵심)
		- 부모 클래스로부터 **`HttpServlet`을 상속** 받아, **서블릿**으로서 동작
		- 스프링 부트는 `DispatcherServlet`을 서블릿으로 자동 등록하면서, **모든 경로**(`urlPatterns="/"`)에 대해서 매핑
		- 흐름
			- 서블릿이 호출되면 `DispatcherServlet`의 부모인 `FrameworkServlet`에서 오버라이드한 `HttpServlet`에서 제공하는 `service()` 메서드가 호출됨
			- 이후 여러 메서드가 호출되다가 **`DispatcherServlet.doDispatch()`를 호출**
	- HandlerMapping
		- **요청 URL**과 **핸들러**(**컨트롤러**)의 매핑
		- **핸들러** (**Handler**)
			- 컨트롤러를 포괄
			- 꼭 컨트롤러 개념이 아니더라도 어떠한 것이든 어댑터가 지원하면 처리 가능
	- **HandlerAdapter** (in 핸들러 어댑터 목록)
		- 다양한 버전의 규격이 다른 핸들러들을 **호환** 가능하게 도움
		- 프레임워크를 **유연**하고 **확장성** 있게 설계 가능
		- **어댑터 패턴 덕분에 프론트 컨트롤러가 다양한 방식의 컨트롤러를 처리 가능**
		- 핵심 메서드
			- `boolean supports(Object handler)`
				- 어댑터가 해당 컨트롤러를 처리할 수 있는지 판단
			- `ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler)`
				- 실제 컨트롤러를 호출하고 ModelAndView 반환
				- 컨트롤러가 ModelAndView를 반환하지 못하면, 어댑터가 직접 생성해서라도 반환
	- ModelAndView
		- **논리 뷰 이름**을 가짐
		- 뷰 렌더링에 필요한 모델 객체 포함
	- ViewResolver (물리 뷰 경로 반환기)
		- **논리 뷰 이름을 실제 물리 뷰 경로로 변경**
		- e.g. `return new View("/WEB-INF/views/" + viewName + ".jsp");`
	- View
		- **물리 뷰 경로**를 가짐
		- 모델 정보와 함께 `render()` 메서드를 호출 (해당 물리명 주소로 servlet의 `forward` 함수 호출)
- 동작 순서
	- 핸들러 조회: 핸들러 매핑을 통해 **요청 URL에 매핑된 핸들러(컨트롤러)를 조회**
	- 핸들러 어댑터 조회: 핸들러를 실행할 수 있는 **핸들러 어댑터 조회**
	- 핸들러 어댑터 실행
	- 핸들러 실행: 핸들러 어댑터가 실제 핸들러 실행
	- `ModelAndView` 반환: 핸들러 어댑터는 **핸들러의 반환 결과를 ModelAndView로 변환해 반환**
	- `ViewResolver` 호출: 뷰 리졸버를 찾고 실행
		- JSP의 경우 `InternalResourceViewResolver`가 자동 등록되고 사용됨
	- `View` 반환: 뷰 리졸버는 **뷰의 논리 이름을 물리 이름으로 바꾸고**, **뷰 객체 반환**
		- JSP의 경우 `InternalResourceView(JstlView)`를 반환 (내부에 `forward()` 로직 존재)
	- **뷰 렌더링**: 뷰 객체의 `render()` 메서드 호출