## 운영체제(Operating System, OS)란?

하드웨어 바로 위에 설치되어 사용자 및 소프트웨어를 하드웨어와 연결시켜주는 시스템 **소프트웨어**이다.

* 협의의 운영체제 : 보통 **커널**을 지칭한다. 커널은 운영체제의 핵심 부분으로 메모리에 상주한다. 전공자 입장에서 주로 이 의미로 많이 쓰인다.

* 광의의 운영체제 : 컴퓨터 부팅 시, 커널 및 커널과 함께 실행되는 주변 시스템 유틸리티를 모두 총칭하는 개념이다.

​    

## 운영체제의 목적

### 1. 컴퓨터 시스템 **자원의 효율적 관리**

* 효율성 : 주어진 하드웨어 자원(CPU, 기억장치, 입출력장치 등)을 활용하여 최대한 성능을 내도록 한다.

> ex) 실행 중인 프로그램들에게 짧은 시간 간격으로 CPU를 번갈아 할당하거나 메모리 공간을 적절히 분배하는 것

* 형평성 : 특정 사용자가 차별받지 않도록 사용자 간의 형평성을 고려하여 자원을 분배한다.

* 소프트웨어 자원(프로세스, 파일, 메시지)을 관리하거나 사용자 및 운영체제 스스로를 보호하기도 한다.

​    

### 2. 사용자에게 편리한 컴퓨터 시스템 이용 환경 제공

* 실제로는 하나의 컴퓨터를 이용하는 여러 사용자들이 마치 자신만의 독자적 컴퓨터에서 프로그램을 실행시키는 듯한 느낌을 받게 한다.
* 또한, 하드웨어를 직접 다루는 복잡한 역할을 대신해준다.

   

## 운영체제의 분류

### 1. 동시 작업 가능 여부

* 단일 작업(single tasking) : 한 번에 하나의 작업만 처리한다. ex) MS-DOS

* 다중 작업(multi tasking) : 동시에 두 개 이상의 작업을 처리한다. ex) UNIX, MS Windows

   

### 2. 사용자 수

* 단일 사용자 ex) MS-DOS, MS Windows 

* 다중 사용자 ex) UNIX, NT server

​    

### 3. 처리 방식

* **시분할(time sharing)** 

여러 작업을 수행할 때, **컴퓨터 처리 능력을 일정한 시간 단위로 분할**하여 사용하는 방식이다. 우리가 주로 사용하는 현대적 범용 컴퓨터는 대부분 이 방식을 사용한다. 일괄 처리 방식에 비해 **짧은 응답시간**을 가지지만 사용자의 수에 따라 처리시간이 달라진다. (0.01초의 처리시간이 사람이 많아질수록 0.1초, 1초와 같이 느려진다.) 이로 인해, **Interactive**한 속성(컴퓨터에 무언가를 입력하면 바로 화면에 결과가 나오는 방식)을 느낄 수 있으며, 실시간 방식과 달리 처리 **시간의 제약이 따로 존재하진 않는다.**

   

* **실시간(Realtime OS)**

**정해진 Deadline에 어떠한 작업이 무조건 마무리되어야 하는 실시간 시스템을 위해 만들어진 OS**이다. 따라서, 한 치의 오차도 발생해서는 안 되는 공장 제어, 미사일 제어, 반도체 공정 등 특수 목적 시스템에 많이 사용된다. 

​    

  · Hard realtime system(경성 실시간 시스템) : 시간을 어기면 큰 문제가 생기는 시스템  ex) 공정 파이프라인

  · Soft realtime system(연성 실시간 시스템) : 약간의 시간 어김이 허용되는 시스템  ex) 영화 스트리밍

   

> 영화 스트리밍, 웹서핑 등에 사용하는 보통의 범용 컴퓨터는 시분할 방식의 OS를 사용하지만 내비게이션 앱이나 블랙박스 영상 촬영 등은 잠깐의 시간 어김도 허용되서는 안 된다. 따라서, 범용 컴퓨터의 OS가 Realtime을 요구하는 Application들을 어떻게 지원해줘야 할 지에 대한 연구도 진행되고 있다.

   

- 일괄처리(batch processing)

과거의 컴퓨터 처리 방식 중 하나로 현대에는 익숙지 않은 방식이다. 작업 요청을 일정량 모아서 한꺼번에 처리하는 방식으로 interactive하지 않다. 다음 작업을 위해서는 작업이 완전히 종료될 때까지 기다려야 하는 불편함이 있다.  

   

> 요즈음의 범용 컴퓨터 OS는 **다중 작업, 다중 사용자, 시분할 처리 방식**의 속성을 가진다.

   

## 다중 작업 관련 용어 정리

아래의 모든 용어는 '컴퓨터에서 여러 작업이 동시에 수행되는 것'을 의미한다.

* Multitasking

* Multiprogramming : 여러 프로그램이 메모리에 올라가 있음을 강조한다.

* Time sharing : CPU의 시간을 분할하여 사용하는 것을 강조한다.

* Multiprocess : process는 실행 중인 프로그램을 뜻하여, 여러 개의 실행 중인 프로그램을 말한다.

 

> Multiprocessor : 하나의 컴퓨터에 여러 CPU(processor)가 붙어 있음을 뜻한다. (하드웨어적으로 강조)

 

## 운영체제의 예

### 1. **유닉스(UNIX)**

초기의 **대형 컴퓨터(서버)**를 위해 만들어진 운영체제로, **multitasking**과 **다중 사용자**가 가능하다. 복잡한 어셈블리어로 유닉스를 만든 것에 한계가 있어, 보다 high level에 해당하는 C언어가 탄생했다. **코드의 대부분이 C언어**로 작성된 유닉스는 덕분에 기계어 집합이 전혀 다른 컴퓨터에도 이식하는 것이 쉬워져 높은 **이식성**을 보였다. (C언어 코드를 단순히 컴파일하면 되었다.) 유닉스는 **최소한의 핵심적인 커널 구조**만 가지며 메모리를 아꼈고, 복잡한 시스템에 맞게 확장이 용이했다. 또한, '공개 Software 정신'의 개념 하에 **소스 코드를 공개**하며 수많은 유닉스 기반의 OS들을 배출했다. System Ⅴ, FreeBSD(버클리 대학교 제작), SunOS, Solaris, Linux 등의 다양한 버전이 그 예이다. 특히, Linux는 개인용 컴퓨터를 비롯해 여러 환경에서 사용 가능한 특징을 보인다.

 

### 2. **Microsoft 운영체제**

**단일 작업**, **단일 사용자**를 상정하며 시작되었다.

* DOS(Disk Operating System) : **단일 사용자용** 운영체제이며, 640KB의 **적은 메모리**는 한계점이다. 이러한 한계가 있는 DOS에 새로운 기능이 계속 추가되며 DOS의 코드는 복잡해지고 누더기(?)가 되었다. 그 이후, DOS 위에서 Windows를 실행시키는 것이 가능해지고 점차 Windows가 독자적인 OS로 독립하였다.

* MS Windows : 제작된 **다중 작업**이 가능한 **GUI 기반 운영체제**이다. 하드웨어를 연결하면 별도의 사용자 조작이나 프로그램 설치 없이 바로 사용 가능한 Plug and Play 지원(그 당시엔 혁신적이었다.), DOS용 응용 프로그램과의 호환성, 풍부한 지원 소프트웨어 등의 특징이 있다.

   

### 3. 이외에도 애플 OS(Macintosh OS→Mac OS), 소형 디바이스(Handleheld device)를 위한 OS(PalmOS, Pocket PC(WinCE), Tiny OS) 등이 존재했고, 점차 iOS 같은 스마트 디바이스(Smart device)를 위한 OS 등 여러 형태의 운영체제로 발전하였다.

   

## 운영체제의 Issue

![img](https://blog.kakaocdn.net/dn/ctwt2W/btqHVnr2PDa/40TlPPB4wkdN2GrXxYiYK1/img.png)

> 운영체제의 구조

* CPU 스케줄링 : 빠른 처리 속도를 가진 CPU지만, 작업들을 어떤 순서로 할당하는 게 가장 효율적일지 고민한다.

* 메모리 관리 : 한정된 메모리를 어떤 작업들에 많게 혹은 적게 배분하고 제외시킬지에 관한 주제이다.

* 파일 관리 : 디스크에 파일을 어떻게 보관할지에 관한 주제이다. 디스크 헤드의 효율적인 움직임을 고민한다.

* 입출력 관리 : 다양한 입출력 장치와 컴퓨터 간의 정보 교환을 어떻게 할지 고민한다. 입출력 장치의 느린 처리속도를 극복하기 위해 빠른 처리 속도를 가진 CPU를 순간적으로 멈추는 Interrupt도 이 주제에서 다룬다.

* 프로세스 관리 : 컴퓨터 소프트웨어(프로그램)들을 어떻게 관리할지에 대한 주제이다.

* 보호 시스템, 네트워킹, 명령어해석기(Command Line Interpreter) 등의 주제도 존재한다.

​    

내 스스로가 운영체제가 되었다고 생각하며 공부해보자 :)