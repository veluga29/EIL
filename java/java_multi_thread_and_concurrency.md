## 멀티태스킹 & 멀티프로세싱
- 프로그램 실행
	- 프로그램을 구성하는 **코드를 순서대로 CPU(=프로세서)에서 연산**하는 일
- 초창기 컴퓨터
	- 하나의 CPU 코어에서 한 프로그램 코드를 모두 수행 후 다른 프로그램 코드 실행
	- e.g. 사용자는 음악 프로그램 끝난 후에야 워드 프로그램 실행 가능해 불편
- 멀티태스킹 (**소프트웨어** 관점 - 운영체제)
	- **단일 CPU**(**단일 CPU 코어**)가 **여러 작업을 동시에 수행하는 것처럼** 보이게 하는 것
		- e.g. 현대 운영체제에서 여러 애플리케이션이 동시에 실행되는 환경
	- **CPU가 매우 빠르게 두 프로그램의 코드를 번갈아 수행**한다면, 사람은 **동시에 실행되는 것처럼 느낄 것**
		- 현대 CPU는 초당 수십억 번 이상의 연산 수행
		- **대략 0.01초(10ms)** 동안 **한 프로그램**을 **수십만 번 연산**
		- 하나의 CPU 코어 -> 프로그램 A 코드 수행 (약 10ms) -> 프로그램 B 코드 수행 (약 10ms) -> 프로그램 A의 이전 실행 중인 코드부터 다시 수행 (약 10ms) -> ... 
- 멀티프로세싱 (**하드웨어** 관점)
	- **여러 CPU**(**여러 CPU 코어**)를 사용하여 **여러 작업을 동시에 수행**하는 것
		- e.g. 멀티코어 프로세서를 사용하는 현대 컴퓨터 시스템
	- **여러 개의 CPU 코어**에서 여러 프로그램이 **물리적으로 동시에 실행**
		- **코어가 2개여도 2개보다 많은 프로그램 실행 가능**
		- 하나의 CPU 코어만 사용하는 시스템보다 동시에 **더 많은 작업을 처리**
		- e.g. CPU 코어 2개에서 프로그램 A, B, C 처리
			- CPU 코어 2개에서 물리적으로 동시에 2개의 프로그램 처리
				- A, B 실행 (약 10ms)
				- B, C 실행 (약 10ms)
				- ...
- **멀티 태스킹과 멀티프로세싱은 함께 일어날 수 있는 개념**

>CPU 코어
>
>최근의 일반적인 컴퓨터는 **하나의 CPU 안에 여러 개의 코어**를 가지는 **멀티코어 프로세서**를 가진다.
>**코어**는 **CPU 안의 실제 연산을 처리하는 장치**를 말한다. 
>과거에는 하나의 CPU 안에 하나의 코어만 들어있었다.

## 프로세스와 스레드
![java_process_and_thread](../images/java_process_and_thread.png)
- 프로세스
	- **운영체제 안**에서 **실행 중**인 프로그램
		- 실행 환경과 자원을 제공하는 **컨테이너** 역할
		- 자바 언어와 비유하면 클래스는 프로그램(=코드뭉치, 파일), 인스턴스는 프로세스
	- 메모리 구성
		- 각 프로세스는 **독립적인 메모리 공간**을 가짐
			- 서로의 메모리에 직접 접근 불가
			- 특정 프로세스에 심각한 문제가 발생해도 **다른 프로세스에 영향 X** (해당 프로세스만 종료)
		- 구성
			- 코드 섹션: 실행할 **프로그램의 코드**가 저장되는 부분
			- 데이터 섹션: **전역 변수** 및 **정적 변수**가 저장되는 부분 (위 그림의 기타에 포함)
			- 힙: **동적으로 할당되는 메모리 영역**
			- 스택: **메서드(함수) 호출** 시 생성되는 **지역 변수**와 반환 주소의 저장 영역 (**스레드에 포함**)
	- **하나 이상의 스레드를 반드시 포함**
- 스레드
	- **프로세스 내에서 실행되는 작업 단위**
		- **CPU**를 사용해 **코드를 하나하나 실행**
	- 메모리 구성
		- 공유 메모리
			- **한 프로세스 내 여러 스레드들**은 프로세스가 제공하는 **메모리 공간을 공유**
			- e.g. 코드 섹션, 데이터 섹션, 힙, 스택을 프로세스 안 모든 스레드가 공유
		- 개별 스택
			- 각 스레드는 **자신의 스택**을 가짐
	- 프로세스보다 **생성 및 관리가 단순하고 가벼움**
- 멀티스레드가 필요한 이유
	- **하나의 프로그램**도 그 안에서 **동시에 여러 작업**이 필요하다
	- e.g.
		- 워드 프로그램 - 프로세스A
			- 스레드1: 문서 편집
			- 스레드2: 자동 저장
			- 스레드3: 맞춤법 검사
		- 유튜브 - 프로세스B
			- 스레드1: 영상 재생
			- 스레드2: 댓글
- 멀티스레드도 단일 코어 스케줄링 & 멀티 코어 스케줄링 모두 발생 가능

>프로그램 실행
>
>프로그램을 실행하면 **운영체제**는 먼저 디스크에 있는 파일 덩어리인 **프로그램을 메모리로 불러와 프로세스를 만든다**. **프로그램이 실행**된다는 것은 사실 **프로세스 안에 있는 코드가 한 줄씩 실행되는 것**이다.
>**코드는 보통 `main()`부터 시작해서 스레드가 하나씩 순서대로 내려가면서 실행**한다.
>한 프로세스 안에는 최소 하나의 스레드가 존재한다. 그래야 프로그램이 실행될 수 있다.

>CPU 스케줄링
>- **운영체제**가 **CPU에 어떤 프로그램을 얼마만큼 실행할지 결정**하는 것
>- CPU를 **최대한 활용**할 수 있는 **다양한 우선순위와 최적화 기법** 사용
>	- e.g. 시분할 기법 (Time Sharing, 시간 공유)
>		- 각 프로그램의 **실행 시간을 분할**해서 마치 동시에 실행되는 것처럼 하는 기법
>- 운영체제는 내부에 **스케줄링 큐**를 가지고, **각각의 스레드는 스케줄링 큐에서 대기**
>	- 스레드들이 운영체제한테 내가 실행되어야 한다고 알리면 운영체제는 해당 스레드들을 큐에 넣음
>	- 운영체제는 큐에서 대기중인 스레드를 하나씩 꺼내 CPU를 통해 실행
>	- 스레드는 CPU 연산을 통해 프로그램 코드를 수행
>	- 운영체제는 10ms 정도 후 작업 중인 스레드를 잠시 멈추고 다시 스케줄링 큐에 넣음
>	- 스케줄링 큐에서 다음 스레드를 꺼내 CPU를 통해 실행
>	- 반복...

>단일 스레드: 한 프로세스 내에 **하나의 스레드**만 존재
>멀티 스레드: 한 프로세스 내에 **여러 스레드**가 존재

## 컨텍스트 스위칭 (Context Switching)
- 컨텍스트 스위칭
	- CPU 스케줄링에 의해 작업 중인 스레드가 교체되는 과정
		- 멈춰지는 스레드는 **수행 위치**와 CPU에서 사용하던 **변수 값들**을 **메모리에 저장**
		- 실행하는 스레드는 **수행 위치**와 CPU에서 사용하던 **변수 값들**을 **메모리에서 CPU로 불러옴**
	- 값을 저장하고 불러오는 과정은 **약간의 비용을 발생시킴**
		- 실제로 컨텍스트 스위칭 시간은 짧지만, **스레드가 매우 많다면 비용이 커질 수 있음**
	- 실제로 **큰 단위 계산**을 할 때 **컨텍스트 스위칭 발생 가능성 높음**
- **멀티스레드는 대부분 효율적**이지만, **컨텍스트 스위칭** 과정이 필요하므로 **항상 효율적이진 않음**
	- 90% 경우는 효율적, 1~3% 경우는 비효율적
	- 예시
		- CPU 코어가 2개이고 스레드 2개 만들어 연산
			- 2배 빠르게 처리 가능 (**효율적**)
		- CPU 코어가 1개인데 스레드 2개 만들어 연산
			- 연산 시간 + **컨텍스트 스위칭 시간** (**비효율적**)
			- 단일 스레드로 연산하는 것이 오히려 효율적
## 스레드 숫자 최적화 전략
- CPU 개수와 스레드 개수
	- CPU 4개, 스레드 2개
		- CPU 100% 활용 X, 컨텍스트 스위칭 비용은 감소
		- 컨텍스트 스위칭이 일어날 수는 있지만 거의 없을 것
	- CPU 4개, 스레드 100개
		- CPU 100% 활용 O, 컨텍스트 스위칭 비용 증가
	- CPU 4개, 스레드 4개
		- **최적 상태** (CPU 100% 활용 O, 컨텍스트 스위칭 비용 거의 X)
		- 스레드 개수로 CPU 코어 개수 + 1개가 이상적 (특정 스레드 대기 시 남은 스레드 활용 가능)
- 스레드 작업 유형
	- CPU 바운드 작업
		- **CPU 연산 능력**을 많이 요구하는 작업
		- e.g. 복잡한 수학 연산, 데이터 분석, 비디오 인코딩, 과학적 시뮬레이션...
	- I/O 바운드 작업
		- **입출력(I/O) 작업**을 많이 요구하는 작업 (대기 시간으로 인해 **CPU 유휴 상태** 빈번)
		- e.g. DB 쿼리 처리, 파일 읽기/쓰기, 네트워크 통신, 사용자 입력 처리...
- 실무 전략
	- **스레드 숫자는 작업 유형에 따라 다르게 설정해야 한다!**
		- CPU 바운드 작업: **CPU 코어 수 + 1개**
			- CPU를 거의 100% 사용하는 작업이므로 **스레드를 CPU 숫자에 최적화**
		- I/O 바운드 작업: **CPU 코어 수 보다 많은 스레드 생성**
			- **성능 테스트** 통해 **CPU를 최대한 활용하는 최적의 스레드 개수** 찾을 것! 
			- 너무 많은 스레드는 **컨텍스트 스위칭 비용** 증가
	- **웹 애플리케이션 서버 실무는 I/O 바운드 작업이 많음** -> **CPU 코어 수 보다 많은 스레드 생성할 것!**
		- 사용자 요청 1개 처리 -> 스레드 1개 필요 (CPU 1%)
		- I/O 작업(DB 쿼리 대기 등)을 생각하면 스레드는 CPU를 거의 사용하지 않고 대기
		- 이 경우 CPU 코어가 4개 있다고 해서 스레드도 4개만 만들면 안됨
			- 동시에 4명의 사용자 요청만 처리 -> CPU 4% 사용 -> **CPU가 심하게 놀고 있음!**
			- 단순 생각해도 100개 스레드 생성 가능 (CPU 100%)
			- 스레드 개수만 늘리면 되는데, 서버 장비를 늘리는 비효율적인 사태가 벌어지기도...
	- 웹 애플리케이션 서버도 상황에 따라 CPU 바운드 작업이 많을 수 있음
		- 이 때는 CPU 코어 수 + 1개 고려
## 스레드 생성 및 실행
- 스레드 생성과 메모리
	![java_thread_in_memory](../images/java_thread_in_memory.png)
	- **자바는 실행 시점**에 **`main`이라는 이름의 스레드**를 만들고, 프로그램의 시작점인 **`main()` 메서드 실행**
	- **새로운 스레드**를 생성 및 시작하면 **자바**는 스레드를 위한 **실행 스택**을 **할당**
		- `start()` 메서드
			- 새로운 스레드를 실행
			- `main` 스레드는 **다른 스레드에게 일을 시작하라고 지시만 하고 바로 빠져나옴**
		- 스레드에 이름을 주지 않으면 임의의 이름 부여 (`Thread-0`, `Thread-1`...)
	- **메서드를 실행**하면 스택 위에 **스택 프레임**이 쌓임
		- **`main` 스레드**는 **`main()` 메서드 스택 프레임** 올리며 시작
		- **새로 만든 스레드**는 **`run()` 메서드 스택 프레임** 올리며 시작
- 유의점
	- 반드시 `run()` 메서드가 아닌 **`start()` 메서드 호출**해야 함
		- `start()` 호출 O -> **실행 스택 생성**되고 **별도의 스레드로 작동**
		- `start()` 호출 X -> `run()` 호출은 단순 함수 실행, 생성한 스레드도 단순한 객체일 뿐
			- 일반적인 메서드 호출 (`main` 스레드의 실행 스택 위에서 실행)
	- **스레드 간 실행 순서를 보장하지 않음** -> 이것이 **멀티스레드**!
		- **스레드는 동시에 실행**되므로 스레드 간 **실행 순서는 얼마든지 달라질 수 있음**
			- CPU 코어가 2개여서 물리적으로 정말 동시에 실행될 수도 있고
			- 하나의 CPU 코어에 시간을 나누어 실행할 수도 있음
- 생성 방법
	- **`Runnable` 인터페이스 구현** (**권장**)
		- 정의
			```java
			public class HelloRunnable implements Runnable {
			    @Override
			    public void run() {
			        System.out.println(Thread.currentThread().getName() + ": run()");
			    }
			}
			```
		- 실행
			- `Thread thread = new Thread(new HelloRunnable());`
			- `thread.start()`
		- **더 유연하고 유지보수하기 좋은 방식**
			- **상속**이 자유로움 (`Thread` 상속 방식은 다른 상속이 불가능)
			- **스레드**와 **작업** 코드가 서로 **분리**되어 가독성 상승
			- 여러 스레드가 동일한 `Runnable` 객체를 공유할 수 있어 **자원 관리가 효율적**
	- `Thread` 클래스 상속
		- 정의
			```java
			public class HelloThread extends Thread {
			
				@Override
				public void run() {
				    System.out.println(Thread.currentThread().getName() + ": run()");
				}
			}
			```
		- 실행
			- `HelloThread thread = new HelloThread();`
			- `thread.start()`
		- 자바는 스레드도 객체로 다룸
		- 스레드가 실행할 코드를 `run()` 메서드에 재정의

>`Thread` 주요 메서드
>
>`Thread.currentThread()`: 해당 코드를 실행하는 스레드 객체 조회 가능
>`Thread.currentThread().getName()`: 실행 중인 스레드의 이름을 조회

>Runnable 인터페이스와 체크 예외
>
>자식 클래스가 부모보다 더 넓은 범위의 예외를 던지면, **일관성을 해치고 예상치 못한 런타임 오류를 초래**할 수 있다. 
>따라서, 자바에서는 메서드 재정의 시 다음과 같은 예외 관련 규칙을 적용한다.
>
>1. 부모 메서드가 체크 예외를 던지지 않는 경우, 자식 재정의 메서드도 던질 수 없다.
>2. 자식 메서드는 부모 메서드가 던질 수 있는 체크 예외의 하위 타입만 던질 수 있다.
>3. 언체크 예외는 강제하지 않으므로 상관없이 던질 수 있다.
>
>**`Runnable` 인터페이스의 `run()` 메서드는 어떤 예외도 던지지 않기 때문에**, 개발자는 `run()` 메서드 재정의시 반드시 **`try-catch` 블록 내에서 체크 예외를 처리**해야 한다.
>예를 들어, **유틸리티 메서드**를 하나 만들어, 내부에서 `try-catch`로 **체크 예외를 잡고 언체크 예외로 변경해 재발생시키는 방법**도 있다.

>`this`와 스레드
>
>`this`는 **호출된 인스턴스 메서드가 소속된 객체를 가리키는 참조**이며, 스택 프레임 내부에 저장된다.
>
>메서드를 호출하는 것은 정확히는 **특정 스레드가 어떤 메서드를 호출**하는 것이다. **스레드**는 메서드 호출을 관리하기 위해 **메서드 단위**로 **스택 프레임**을 만든다. 이 때 인스턴스 메서드를 호출하면 **어떤 인스턴스 메서드를 호출했는지 기억하기 위해** 해당 인스턴스의 참조값을 스택 프레임 내부에 저장해두는데, 이것이 `this`다.
>
>따라서, 특정 메서드 안에서 `this`를 호출하면 스택프레임 내의 `this` 값을 불러서 사용하고 필드 접근시 `this`를 생략하면 자동으로 `this`를 참고해 필드에 접근한다.
>
>참고로 인스턴스 메서드는 `this`가 있지만 **클래스 메서드는 `this`가 없다.**

## 데몬 스레드 (Daemon Thread)
- 스레드는 2가지 종류로 구분
	- 사용자 스레드
		- 프로그램의 **주요 작업** 수행
		- 모든 사용자 스레드가 종료되면 JVM도 종료
			- Main 뿐만 아니라 다른 사용자 스레드까지 모두 종료되어야 자바 종료 (중간에 작업 끊김 X)
	- 데몬 스레드
		- **백그라운드**에서 **보조적인 작업** 수행
		- 모든 사용자 스레드가 종료되면 JVM이 종료되고 데몬 스레드도 자동 종료 (작업 끊김)
- 데몬 스레드 실행 방법
	- `thread.setDaemon(true) // 데몬 스레드로 설정 (기본값은 false, user 스레드가 기본)`
	- `thread.start() // 데몬 스레드 여부는 start() 실행 이후에는 변경되지 않음`

>데몬
>
>컴퓨터 과학에서는 사용자에게 보이지 않으면서 **시스템의 백그라운드에서 작업을 수행하는 것**을 데몬 스레드, 데몬 프로세스라고 한다. 예를 들어, 사용하지 않는 파일이나 메모리를 정리하는 작업들이 있다.

## 스레드 기본 정보
- 스레드 이름 부여
	- `Thread myThread = new Thread(new HelloRunnable(), "myThread");`
		- 스레드 이름이 "myThread"
	- 디버깅, 로깅 목적으로 유용
- `Thread` 클래스 메서드
	- `threadId()`: **스레드 고유 식별자** 반환 (JVM 내 각 스레드에 대해 유일)
	- `getName()`: **스레드 이름** 반환 (스레드 이름은 중복 가능)
	- `getPriority()`: **스레드의 우선순위** 반환 (1: 가장 낮음 ~ 10: 가장 높음, 기본값: 5)
		- `setPriority()`로 변경 가능하지만, 실제 실행 순서는 운영체제에 달려있음
	- `getThreadGroup()`: **스레드가 속한 그룹**을 반환
	- `getState()`: 스레드의 현재 상태를 반환 (`Thread.State` 열거형에 정의된 상수)
		- NEW, RUNNABLE, BLOCKED, WAITING, TIMED_WAITING, TERMINATED

>부모 스레드
>
>**새로운 스레드를 생성하는 스레드**를 의미한다.
>**스레드는 기본적으로 다른 스레드에 의해 생성**된다. (`main` 스레드는 제외)

>스레드 그룹
>
>**직접적으로 잘 사용하지 않는다.** 스레드를 그룹화하여 관리할 수 있는 기능을 제공한다. 
>스레드 그룹에는 특정 작업을 일괄적으로 적용할 수 있다. (e.g. 일괄 종료, 우선순위 설정)
>모든 스레드는 부모 스레드와 동일한 스레드 그룹에 속한다.
>`main` 스레드는 기본으로 제공되는 `main` 스레드 그룹에 속한다.

## 스레드의 생명 주기
![life_cycle_of_thread](../images/life_cycle_of_thread.png)
- **`NEW`**
	- 스레드가 **생성**되었으나 **아직 시작되지 않은** 상태
	- `Thread` 객체는 생성되었지만 `start()` 메서드가 호출되지 않음
- **`RUNNABLE`**
	- 스레드가 **실행 중**이거나 **실행될 준비**가 된 상태 (=CPU에서 실행될 수 있음)
	- `start()` 메서드 호출 후 상태
	- `RUNNABLE` 상태의 모든 스레드가 **동시 실행되지는 않음** (**운영체제 스케줄러**가 CPU 할당하기 때문)
	- 자바에서는 운영체제 스케줄러에 있든 CPU에서 실제 실행되고 있든 **모두 `RUNNABLE` 상태** (구분 X)
- **`TERMINATED`**
	- 스레드가 **실행을 마친** 상태 (`run()` 메서드 **정상 종료** 혹은 **예외 발생 종료**)
	- 스레드는 한 번 **종료**되면 **다시 시작할 수 없음** (새로 만들어서 실행해야 함)
- **일시 중지 상태**
	- **`BLOCKED`** 
		- 스레드가 **동기화 락**을 기다리는 상태
		- e.g. `synchronized` 블록 진입 위해 락 획득 대기
	- **`WAITING`**
		- 스레드가 **다른 스레드의 특정 작업 완료**를 **무기한** 기다리는 상태
		- e.g. `wait()`, `join()` 호출 시
		- 다른 스레드가 `notify()`, `notifyAll()` 호출하거나 `join()`이 완료될 때까지 기다림
	- **`TIMED_WAITING`**
		- 스레드가 **다른 스레드의 특정 작업 완료**를 **일정 시간 동안** 기다리는 상태
		- e.g. `sleep(long millis)`, `wait(long timeout)`, `join(long millis)` 호출 시
		- 주어진 시간이 경과하거나 다른 스레드가 해당 스레드를 깨우면 이 상태를 벗어남
## 다른 스레드의 작업 기다리기 - `join()`
- **다른 스레드의 작업 완료를 기다려하는 상황**에 사용
	-  `join()`: **무한정** 기다릴 때 사용 (`WAITING`)
	- `join(ms)`: **특정 시간**만 기다릴 때 사용 (`TIMED_WAITING`)
- 진행 과정
	- 호출 스레드는 **`WAITING`** 상태가 됨
	- 대상 스레드가 **`TERMINATED`** 상태가 될 때까지 **대기**
		- 대상 스레드가 `TERMINATED` 상태가 되면 `RUNNABLE` 상태가 되어 다음 코드 수행
		- 대상 스레드가 이미 `TERMINATED` 상태라면 바로 빠져나옴
- e.g. 연산을 두 개의 스레드로 나누어 진행하고 완료된 후 결과를 합쳐 사용
	- `thread-1`: 1 ~ 50까지 더하기
	- `thread-2`: 51 ~ 100까지 더하기
	- `main`: 두 스레드의 계산 결과를 받아 합치기
## 스레드 작업을 중간에 중단하기
- **다른 스레드**의 작업을 중간에 중단하기
	- **인터럽트** (**권장**)
		- **대기 상태**의 스레드(`WAITING`, `TIMED_WAITING`...)를 **직접 깨워**, `RUNNABLE` 상태로 변경
		- 작업 중단 지시 후, 거의 **즉각적으로** 인터럽트 발생
		- 인터럽트 상태가 되면 **`InterruptedException`** 예외 발생
			- 상태 변화
				- 인터럽트 상태(`true`) -> `InterruptedException` -> 인터럽트 상태(`false`)
			- **`InterruptedException`을 던지는 메서드**를 **호출**하거나 **호출 중**일 때만 예외가 발생
				- e.g. `Thread.sleep()`, `join()`
				- 일반 코드에서는 예외가 발생하지 않음
		- 관련 메서드
			- `interrupt()`: 특정 스레드에 인터럽트 걸기
			- `isInterrupted()`: 인터럽트 상태 **단순 확인** (인터럽트 상태 변경 X)
			- `interrupted()`: 인터럽트 상태를 **확인** 및 **상태 변경**
				- 스레드가 인터럽트 상태면 `true`를 반환 및 **인터럽트 상태 `false`로 변경**
				- 스레드가 인터럽트 상태가 아니면 `false`를 반환 (상태 변경 X)
		- 인터럽트 직접 체크 시, **`interrupted()` 사용할 것!** (with `interrupt()`) 
			- `InterruptedException`을 던지는 메서드가 없을 때도 인터럽트 사용 가능
			- `isInterrupted()`는 인터럽트 상태가 `true`로 남겨진 채 유지됨
				- 다른 곳에서도 계속 인터럽트가 발생할 수 있어 위험
		- 방법 예시
			- Task 주요 코드 (Runnable)
				- `while (!Thread.interrupted()) {...}`
			- `main` 스레드가 `thread.interrupt()` 실행해 `work` 스레드에 인터럽트 지시
	- 변수 사용하기
		- 방법 예시
			- Task 주요 코드 (Runnable)
				- `volatile boolean runFlag = true;`
				- `while (runFlag) {...}`
			- `main` 스레드가 `runFlag = false;`를 실행해 `work` 스레드에 작업 중단 지시
		- 문제점
			- `work` 스레드가 **작업 중단 지시에 바로 반응 불가** (**반응성이 느림**)
			- `while` 조건문을 읽을 때에서야 인지하므로 루프 내 작업이 길다면, 반응이 더 느려짐
- **스레드** **스스로** 작업을 중간에 중단하기 (**`yield`**, **양보하기**)
	- 현재 스레드가 크게 바쁘지 않다면, 스케줄링 큐에 대기 중인 다른 스레드에게 **CPU 실행 기회**를 **양보**
	- 현재 스레드는 **다시 스케줄링 큐로 돌아감** (**`RUNNABLE` 상태 유지**)
	- **CPU 코어 수보다 많은 스레드가 있을 때** 의미가 있음
	- `yield`는 스케줄러에게 **힌트**만 줄 뿐, 실행 순서 강제 X
		- 굳이 양보할 필요 없는 상황이면 본인 스레드 계속 실행 (운영체자가 최적화)
	- 구현 예시
		```java
		while (!Thread.interrupted()) {
		    if (jobQueue.isEmpty()) {
				Thread.yield(); // 추가
				continue; 
			}
			... 
		}
		```
		- 최대한 **실시간으로 확인** 원할 시 `yield()`가 효율적
		- 만일 좀 더 오래 기다려도 될 것 같아 **CPU 사용을 최대한 줄이고 싶다면** `sleep()`도 괜찮음
	- 참고: `sleep()`의 단점
		- 복잡한 상태 변화 과정 (`RUNNABLE` -> `TIMED_WAITING` -> `RUNNABLE`)
		- 특정 시간만큼 스레드가 실행되지 않음 (양보할 상황이 아닌데도 휴식)
## 메모리 가시성 (Memory Visibility)
![java_memory_visibility](../images/java_memory_visibility.png) 
- 멀티 스레딩 환경에서 **한 스레드가 변경한 값**이 **다른 스레드에서 언제 보이는지**에 대한 문제
- CPU와 캐시 메모리
	- **CPU**는 처리 성능을 개선하기 위해 **캐시 메모리**를 사용 (L1, L2, L3 캐시...)
	- 현대 CPU는 코어 단위로 캐시 메모리를 보유
- **각 스레드**가 **각자의 캐시 메모리**를 바라보고 작업해 **서로 값 변경을 감지하지 못함**
	- 스레드가 특정 변수 값 사용 시, 점유하는 코어의 **캐시 메모리로 값을 불러옴** (From 메인 메모리)
	- 값 변경 시, **캐시 메모리의 값만 변경** (메인 메모리에 **즉시 반영 X**)
	- **메인 메모리 반영 및 읽기 시점**은 **알 수 없음**!
		- 주로 **컨택스트 스위칭**이 있을 때 **캐시 메모리 함께 갱신** (`sleep()`, 콘솔 출력...)
		- 그러나 환경마다 다르고 갱신이 일어나지 않을 수도 있음
- **`volatile`**
	![java_volatile](../images/java_volatile.png)
	- **성능을 약간 포기**하는 대신에, **값 읽기 및 쓰기**를 모두 **메인 메모리에 직접 접근**해 진행
	- 사용 상황
		- 여러 스레드에서 **같은 시점에 정확히 같은 데이터를 보는게 중요**할 때 사용
		- 캐시 메모리보다 **성능이 떨어지므로 꼭 필요한 곳에만 사용!** (약 5배 차이, 환경에 따라 다름)