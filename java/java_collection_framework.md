## 자바 컬렉션 프레임 워크
![java_collection_framework_overview](../images/java_collection_framework_overview.png)
- 자바는 컬렉션 프레임워크를 통해 **다양한 자료구조**를 **인터페이스, 구현, 알고리즘**으로 지원
- 데이터 컬렉션을 **효율적으로 저장하고 처리**하기 위한 **통합 아키텍처** 제공
- **핵심 인터페이스**
	- `Collection`
		- **단일 루트 인터페이스**로 모든 컬렉션 클래스가 상속 받음
		- 필요성
			- **가장 기본적인 인터페이스**로 다양한 컬렉션 타입이 공통적으로 따라야하는 **기본 규약** 정의
			- 이같은 설계는 **일관성**, **재사용성**, **확장성** 향상시키고 **다형성** 이점 제공
		- 주요 메서드
			- `add(E e)` : 컬렉션에 요소를 추가
			- `remove(Object o)` : 주어진 객체를 컬렉션에서 제거
			- `size()` : 컬렉션에 포함된 요소의 수를 반환
			- `isEmpty()` : 컬렉션이 비어 있는지 확인
			- `contains(Object o)` : 컬렉션이 특정 요소를 포함하고 있는지 확인
			- `iterator()` : 컬렉션의 요소에 접근하기 위한 반복자를 반환
			- `clear()` : 컬렉션의 모든 요소를 제거
	- `List`
		- **순서**가 있는 컬렉션
		- **중복 O**
		- **인덱스** 통한 요소 **접근 O**
		- 구현
			- **`ArrayList`**(주로 사용): 내부적으로 **배열** 사용
			- `LinkedList`: 내부적으로 **연결 리스트** 사용
	- `Set`
		- **중복을 허용하지 않는** 컬렉션
		- **인덱스** 통한 요소 **접근 X**
		- 구현
			- **`HashSet`**(주로 사용): 내부적으로 **해시 테이블** 사용
			- `LinkedHashSet`: 내부적으로 **해시 테이블**과 **연결리스트** 사용
			- `TreeSet`: 내부적으로 **레드-블랙 트리** 사용
	- `Queue`
		- **요소 처리 전 보관**하는 컬렉션
		- 구현
			- **`ArrayDeque`**(주로 사용): 내부적으로 **배열 기반 원형 큐** 사용 (대부분의 경우 **빠름**)
			- `LinkedList`: 내부적으로 **연결리스트** 사용
			- `PriorityQueue`
	- `Map` (**`Collection` 상속 X**)
		- **키와 값 쌍**으로 요소를 **저장**하는 객체
		- 구현
			- **`HashMap`**(주로 사용): 내부적으로 **해시 테이블** 사용
			- `LinkedHashMap`: 내부적으로 **해시 테이블**과 **연결리스트** 사용
			- `TreeMap`: 내부적으로 **레드-블랙 트리** 사용
- **알고리즘**
	- 컬렉션 프레임워크는 데이터 처리 및 조작 알고리즘 제공 (**정렬, 검색, 순환, 변환** 등)
	- 제공 방법
		- 자료구조 **자체적으로 기능** 제공
		- **`Collections`** 와 **`Arrays`** 클래스에 **정적 메서드 형태**로 구현
- **실무 선택 전략**
	- **순서가 중요 O**, **중복 허용 O** 경우: **`List`** 인터페이스를 사용
		- **`ArrayList`** 선택 (**주로 사용**)
		- 추가/삭제 작업이 앞쪽에서 빈번하다면 `LinkedList` (성능상 더 좋은 선택)
	- **중복 허용 X** 경우: **`Set`** 인터페이스 사용
		- 순서가 중요하지 않다면 **`HashSet`** (**주로 사용**)
		- 순서를 유지해야 하면 `LinkedHashSet`
		- 정렬된 순서가 필요하면 `TreeSet`
	- **요소를 키-값 쌍으로 저장**하려는 경우: **`Map`** 인터페이스를 사용
		- 순서가 중요하지 않다면 **`HashMap`** (**주로 사용**)
		- 순서를 유지해야 한다면 `LinkedHashMap`
		- 정렬된 순서가 필요하면 `TreeMap`
	- **요소를 처리하기 전에 보관**해야 하는 경우: **`Queue`** , **`Deque`** 인터페이스를 사용
		- **`ArrayDeque`** 선택 (**주로 사용**, 스택/큐 구조 모두에서 **가장 빠름**)
		- 우선순위에 따라 요소를 처리해야 한다면 `PriorityQueue`
## 배열 (Array)
![java_array](../images/java_array.png)
- 가장 **기본**적인 자료구조
- 특징
	- 데이터가 **메모리 상에 순서대로 붙어서 존재**
	- 데이터가 아무리 많아도 **인덱스**를 사용해 **한번의 계산**으로 **빠르게 자료 위치 찾음**
		- 공식: **`배열의 시작 참조 + (자료의 크기 * 인덱스 위치)`**
			- `arr[0]: x100 + (4byte * 0): x100`
			- `arr[1]: x100 + (4byte * 1): x104`
			- `arr[2]: x100 + (4byte * 2): x108`
	- **검색**은 배열의 데이터를 **하나하나 확인**해야해서 **한번에 찾을 수 없음**
	- 데이터를 중간에 **추가**하면 **기존 데이터가 오른쪽으로 한 칸씩 이동해야 함**
- 장점
	- **인덱스** 사용 시 **최고의 효율**
- 단점
	- **배열의 크기**가 생성하는 시점에 **정적**으로 정해짐
- 시간 복잡도
	- 인덱스 조회, 입력, 변경: **O(1)**
	- 데이터 검색: O(N)
	- 데이터 추가: O(N)
		- 배열의 첫번째 위치에 추가: O(N)
		- 배열의 중간 위치에 추가: O(N)
		- 배열의 마지막 위치에 추가: **O(1)**
